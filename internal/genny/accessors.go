package genny

import (
	"context"
	"fmt"
	"go/format"
	"os"
	"strings"

	"github.com/samsarahq/go/oops"
)

type AccessorParams struct {
	GoTypeName   string
	APITypeName  string
	ResourceName string
}

var accessorsToGen = []*AccessorParams{
	{
		GoTypeName:   "Condition",
		APITypeName:  "apiCondition",
		ResourceName: "conditions",
	},
	{
		GoTypeName:   "AbilityScore",
		APITypeName:  "apiAbilityScore",
		ResourceName: "ability-scores",
	},
}

func GenerateAccessors(ctx context.Context, genFilePath string) error {
	f, err := os.Create(genFilePath)
	if err != nil {
		return oops.Wrapf(err, "unable to create generated_accessors.go file")
	}
	defer f.Close()

	headerStr, _ := buildFileHeader(ctx)
	f.WriteString(headerStr)
	f.WriteString("\n")

	for _, accessor := range accessorsToGen {
		allStr, _ := buildAllAccessor(ctx, accessor)
		f.WriteString(allStr)

		byIndexStr, _ := buildByIndexAccessor(ctx, accessor)
		f.WriteString(byIndexStr)
	}

	return err
}

func buildFileHeader(ctx context.Context) (string, error) {
	headerLines := []string{
		"// Code generated by genny; DO NOT EDIT.\n",
		"package api\n",
		"import (",
		"\"context\"\n",
		"\"github.com/samsarahq/go/oops\"\n)\n",
	}

	headerStr := strings.Join(headerLines, "\n")
	formattedheaderStr, err := format.Source([]byte(headerStr))
	if err != nil {
		return "", oops.Wrapf(err, "unable to get formatted header string")
	}

	return string(formattedheaderStr), nil
}

func buildAllAccessor(ctx context.Context, a *AccessorParams) (string, error) {
	allAccessorLines := []string{
		fmt.Sprintf("// %sAll returns a slice of all %s, or an error if unsuccessful.", a.GoTypeName, a.GoTypeName),
		fmt.Sprintf("func (c *Client) %sAll(ctx context.Context) ([]*%s, error) {", a.GoTypeName, a.GoTypeName),
		fmt.Sprintf("res, err := allHelper(ctx, c, \"%s\")", a.ResourceName),
		fmt.Sprintf("if err != nil {"),
		fmt.Sprintf("return nil, oops.Wrapf(err, \"unable to get resource list for %s\")\n}\n", a.ResourceName),
		fmt.Sprintf("resList := []*%s{}", a.GoTypeName),
		fmt.Sprintf("for _, resource := range res.Resources {"),
		fmt.Sprintf("parsedRes, err := c.%sByIndex(ctx, resource.Index)", a.GoTypeName),
		fmt.Sprintf("if err != nil {"),
		fmt.Sprintf("return nil, oops.Wrapf(err, \"unable to get %s with index %%s for list\", resource.Index)\n}", a.ResourceName),
		fmt.Sprintf("resList = append(resList, parsedRes)\n}\n"),
		fmt.Sprintf("return resList, nil\n}\n\n"),
	}

	allAccessorStr := strings.Join(allAccessorLines, "\n")
	formattedAccessorStr, err := format.Source([]byte(allAccessorStr))
	if err != nil {
		return "", oops.Wrapf(err, "unable to get formatted all accessor for %s", a.GoTypeName)
	}

	return string(formattedAccessorStr), nil
}

func buildByIndexAccessor(ctx context.Context, a *AccessorParams) (string, error) {
	byIndexAccessorLines := []string{
		fmt.Sprintf("// %sByIndex returns the %s with the given index, or an error if unsuccessful.", a.GoTypeName, a.GoTypeName),
		fmt.Sprintf("func (c *Client) %sByIndex(ctx context.Context, index string) (*%s, error) {", a.GoTypeName, a.GoTypeName),
		fmt.Sprintf("res := %s{}", a.APITypeName),
		fmt.Sprintf("if err := byIndexHelper(ctx, c, &res, \"%s\", index); err != nil {", a.ResourceName),
		fmt.Sprintf("return nil, oops.Wrapf(err, \"unable to get resource: %s with index: %%s\", index)\n}", a.ResourceName),
		fmt.Sprintf("return res.convert(), nil\n}\n\n"),
	}

	byIndexAccessorStr := strings.Join(byIndexAccessorLines, "\n")
	formattedAccessorStr, err := format.Source([]byte(byIndexAccessorStr))
	if err != nil {
		return "", oops.Wrapf(err, "unable to get formatted by index accessor for %s", a.GoTypeName)
	}

	return string(formattedAccessorStr), nil
}
