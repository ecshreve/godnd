package genny

import (
	"context"
	"fmt"
	"go/format"
	"os"
	"strings"

	"github.com/samsarahq/go/oops"
)

func GenerateTypesV2(ctx context.Context, resourceNames []string, genFilePath string) error {
	f, err := os.Create(genFilePath)
	if err != nil {
		return oops.Wrapf(err, "unable to create generated_types.go file")
	}
	defer f.Close()

	f.WriteString("// Code generated by genny; DO NOT EDIT.\n\n")
	f.WriteString("package api\n\n")

	for _, resourceName := range resourceNames {
		rawResFileStr, err := dumpResourceFileToString(ctx, resourceName)
		if err != nil {
			return oops.Wrapf(err, "unable to dump resource file for %s", resourceName)
		}

		allEndpoints, err := getAllEndpoints(ctx, rawResFileStr)
		if err != nil {
			return oops.Wrapf(err, "unable to get endpoints for %s", resourceName)
		}

		for _, endpointStr := range allEndpoints {
			endpointURL, err := getEndpointURL(ctx, endpointStr)
			if err != nil {
				return oops.Wrapf(err, "unable to get URL for endpoint %s", endpointStr)
			}

			goTypeStr, err := buildGoTypeStrFromEndpointStr(ctx, endpointStr)
			if err != nil {
				return oops.Wrapf(err, "unable to build go type string for endpoint %s", endpointURL)
			}
			f.WriteString(fmt.Sprintf("// generated response type for %s\n", endpointURL))
			f.WriteString(goTypeStr)
			f.WriteString("\n\n")
		}
	}
	return nil
}

func buildGoTypeStrFromEndpointStr(ctx context.Context, endpointStr string) (string, error) {
	fieldTableStr, err := getFieldTable(ctx, endpointStr)
	if err != nil {
		return "", oops.Wrapf(err, "unable to build go type string for endpoint %s", endpointStr)
	}

	goTypeName, err := getTypeNameFromFieldTable(ctx, fieldTableStr)
	if err != nil {
		return "", oops.Wrapf(err, "unable to get go type name for endpoint %s", endpointStr)
	}

	goFields, err := buildGoFieldStrsFromFieldTable(ctx, fieldTableStr)
	if err != nil {
		return "", oops.Wrapf(err, "unable to get go type fields for endpoint %s", endpointStr)
	}

	goFieldStr := strings.Join(goFields, "\n")
	goTypeStr := fmt.Sprintf("type api%s struct {\n%s\n}", goTypeName, goFieldStr)
	formattedGoTypeStr, err := format.Source([]byte(goTypeStr))
	if err != nil {
		return "", oops.Wrapf(err, "unable to get formatted go type string for endpoint %s", endpointStr)
	}

	return string(formattedGoTypeStr), nil
}

func buildGoFieldStrsFromFieldTable(ctx context.Context, fieldTableStr string) ([]string, error) {
	tableRows, _ := getTableRows(ctx, fieldTableStr)

	var fields []string
	for _, row := range tableRows {
		rowElems, err := getTableRowElements(ctx, row)
		if err != nil {
			return nil, oops.Wrapf(err, "unable to elements for row %s", row)
		}

		rowElemContents, err := getTableRowElementContents(ctx, rowElems)
		if err != nil {
			return nil, oops.Wrapf(err, "unable to get element contents for row %s", row)
		}

		parsedFieldType, err := parseFieldType(ctx, rowElemContents.FieldTypeRaw)
		if err != nil {
			return nil, oops.Wrapf(err, "unable to parse field type for row %s", row)
		}
		parsedFieldName := snakeToCamel(rowElemContents.FieldNameRaw)
		goTypeField := buildGoTypeField(ctx, parsedFieldName, rowElemContents.FieldNameRaw, parsedFieldType)
		fields = append(fields, goTypeField)
	}

	return fields, nil
}
