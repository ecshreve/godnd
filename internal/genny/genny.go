package genny

import (
	"context"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"regexp"
	"strings"

	"github.com/samsarahq/go/oops"
)

type endpointForGen struct {
	url        string
	typeString string
}

type apiResource struct {
	name            string
	docFilePath     *string
	urlSuffix       *string
	goTypeStrForGen *string
}

func GenerateTypesV2(ctx context.Context, resourceNames []string) error {
	for _, resourceName := range resourceNames {
		rawResFileStr, err := dumpResourceFileToString(ctx, resourceName)
		if err != nil {
			return oops.Wrapf(err, "unable to dump resource file for %s", resourceName)
		}

		fmt.Println(rawResFileStr)
	}
	return nil
}

// GenerateTypes takes a slice of API resource strings and generates Go types in
// a new file at the given path. It returns an error if unable to create the file.
//
// Note: it does not return an error if unable to generate a type for one of the
// resources, rather it logs the error and continues.
func GenerateTypes(ctx context.Context, resourceRefs []string, genFilePath string) error {
	f, err := os.Create(genFilePath)
	if err != nil {
		return oops.Wrapf(err, "unable to create generated_types.go file")
	}
	defer f.Close()

	f.WriteString("// Code generated by genny; DO NOT EDIT.\n\n")
	f.WriteString("package api\n\n")
	for _, resource := range resourceRefs {
		parsedEndpoints, err := parseResourceFile(resource)
		if err != nil {
			log.Println(oops.Wrapf(err, "unable to generate go types from resource file for %s", resource))
			continue
		}

		for _, parsedEndpoint := range parsedEndpoints {
			f.WriteString(fmt.Sprintf("// generated response type for %s\n", parsedEndpoint.url))
			f.WriteString(parsedEndpoint.typeString)
			f.WriteString("\n\n")
		}
	}

	return nil
}

func parseResourceFile(resourceName string) ([]endpointForGen, error) {
	docFilePath := fmt.Sprintf("%s/doc-resource-%s.ejs", DocFilePath, resourceName)
	docFile, err := os.Open(docFilePath)
	if err != nil {
		return nil, oops.Wrapf(err, "error opening doc file for resource: %s with path: %s", resourceName, docFilePath)
	}

	b, err := ioutil.ReadAll(docFile)
	if err != nil {
		return nil, oops.Wrapf(err, "error reading doc file for resource: %s", resourceName)
	}
	rawStr := string(b)

	result := parseEndpoints(rawStr)
	return result, nil
}

func parseEndpoints(fullDoc string) []endpointForGen {
	fullEndpointRe := regexp.MustCompile(`(?s)<h3.*?>.*?</h3>.*?<table>(\s|.)*?</table>`)
	endpointRefRe := regexp.MustCompile(`<h3.*?>.*? (.*?)</h3>`)
	allRawEndpoints := fullEndpointRe.FindAllString(fullDoc, -1)

	var parsedEndpoints []endpointForGen
	for _, e := range allRawEndpoints {
		endpointRef := endpointRefRe.FindStringSubmatch(e)[1]
		endpointTypeStr := parseEndpoint(e)
		parsedEndpoints = append(parsedEndpoints, endpointForGen{url: endpointRef, typeString: endpointTypeStr})
	}
	return parsedEndpoints
}

func parseEndpoint(endpointStr string) string {
	typeTableRe := regexp.MustCompile(`(?s)<h4>(.*?)</h4>\s*<table>(\s|.)*?</table>`)
	typeTable := typeTableRe.FindString(endpointStr)
	return parseTable(typeTable)
}

func parseTable(table string) string {
	tableTitleRe := regexp.MustCompile(`<h4>(.*?)</h4>\s*<table>`)
	tableTitle := tableTitleRe.FindStringSubmatch(table)[1]
	typeName := spaceSepToCamel(tableTitle)

	tableRowRe := regexp.MustCompile(`(?s)<tr>\s*(<td.*?>.*?</td>\s*){3}\s*</tr>`)
	tableRows := tableRowRe.FindAllString(table, -1)

	var parsedRows []string
	for _, row := range tableRows {
		parsedRows = append(parsedRows, parseTableRow(row))
	}
	fields := strings.Join(parsedRows, "\n")

	// TODO: add error handling
	typeStr := fmt.Sprintf("type api%s struct {\n%s\n}", typeName, fields)
	formattedTypeStr, _ := format.Source([]byte(typeStr))

	return string(formattedTypeStr)
}

func parseTableRow(row string) string {
	rowElementRe := regexp.MustCompile(`(?s)<td.*?>.*?</td>`)
	rowElements := rowElementRe.FindAllString(row, -1)

	elemContentsRe := regexp.MustCompile(`(?s)<td.*?>(.*?)</td>`)
	fieldNameRaw := elemContentsRe.FindStringSubmatch(rowElements[0])[1]
	fieldName := snakeToCamel(fieldNameRaw)

	fieldTypeRaw := elemContentsRe.FindStringSubmatch(rowElements[2])[1]
	fieldType := parseFieldTypeOLD(fieldTypeRaw)

	parsed := fmt.Sprintf("%s %s `json:\"%s\"`", fieldName, fieldType, fieldNameRaw)

	return parsed
}

func parseFieldTypeOLD(elem string) string {
	fieldType := ""
	if regexp.MustCompile(`object`).MatchString(elem) {
		fieldType = fmt.Sprintf("map[string]interface{}")
	} else if regexp.MustCompile(`APIReference`).MatchString(elem) {
		fieldType = fmt.Sprintf("APIReference")
	} else if regexp.MustCompile(`Choice`).MatchString(elem) {
		fieldType = fmt.Sprintf("Choice")
	} else if regexp.MustCompile(`Cost`).MatchString(elem) {
		fieldType = fmt.Sprintf("Cost")
	} else if regexp.MustCompile(`AbilityBonus`).MatchString(elem) {
		fieldType = fmt.Sprintf("AbilityBonus")
	} else {
		scalar := regexp.MustCompile(`\S+$`).FindString(elem)
		fieldType = fmt.Sprintf("%s", apiScalarToGoScalar[scalar])
	}

	if fieldType == "" && regexp.MustCompile(`(?s).*string.+`).MatchString(elem) {
		fieldType = fmt.Sprintf("URLRefString")
	}

	// TODO: figure out how to handle the spells object returned from the
	// subclasses endpoint so we don't use an empty interface.
	if regexp.MustCompile(`list`).MatchString(elem) {
		if fieldType == "" {
			fieldType = fmt.Sprintf("interface{}")
		}
		fieldType = fmt.Sprintf("[]%s", fieldType)
	}

	return fieldType
}
