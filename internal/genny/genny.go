package genny

import (
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"regexp"
	"strings"

	"github.com/samsarahq/go/oops"
)

type endpointForGen struct {
	url        string
	typeString string
}

func GenerateTypes(resourceRefs []string) {
	f, _ := os.Create("/Users/ericshreve/github.com/godnd/pkg/api/generated_types.go")
	defer f.Close()

	f.WriteString("// Code generated by genny; DO NOT EDIT.\n\n")
	f.WriteString("package api\n\n")
	for _, resource := range resourceRefs {
		parsedEndpoints, err := parseResourceFile(resource)
		if err != nil {
			log.Fatalf("unable to parse resource file for %s", resource)
		}

		for _, parsedEndpoint := range parsedEndpoints {
			f.WriteString(fmt.Sprintf("// generated response type for %s\n", parsedEndpoint.url))
			f.WriteString(parsedEndpoint.typeString)
			f.WriteString("\n\n")
		}
	}
}

func parseResourceFile(resourceName string) ([]endpointForGen, error) {
	docFilePath := fmt.Sprintf("%s/doc-resource-%s.ejs", DocFilePath, resourceName)
	docFile, err := os.Open(docFilePath)
	if err != nil {
		return nil, oops.Wrapf(err, "error opening doc file for resource: %s with path: %s", resourceName, docFilePath)
	}

	b, err := ioutil.ReadAll(docFile)
	if err != nil {
		return nil, oops.Wrapf(err, "error reading doc file for resource: %s", resourceName)
	}
	rawStr := string(b)

	result := parseEndpoints(rawStr)
	return result, nil
}

func parseEndpoints(fullDoc string) []endpointForGen {
	fullEndpointRe := regexp.MustCompile(`(?s)<h3>.*?</h3>.*?<table>(\s|.)*?</table>`)
	endpointRefRe := regexp.MustCompile(`<h3>.*? (.*?)</h3>`)
	allRawEndpoints := fullEndpointRe.FindAllString(fullDoc, -1)

	var parsedEndpoints []endpointForGen
	for _, e := range allRawEndpoints {
		endpointRef := endpointRefRe.FindStringSubmatch(e)[1]
		endpointTypeStr := parseEndpoint(e)
		parsedEndpoints = append(parsedEndpoints, endpointForGen{url: endpointRef, typeString: endpointTypeStr})
	}
	return parsedEndpoints
}

func parseEndpoint(endpointStr string) string {
	typeTableRe := regexp.MustCompile(`(?s)<h4>(.*?)</h4>\s*<table>(\s|.)*?</table>`)
	typeTable := typeTableRe.FindString(endpointStr)
	return parseTable(typeTable)
}

func parseTable(table string) string {
	tableTitleRe := regexp.MustCompile(`<h4>(.*?)</h4>`)
	tableTitle := tableTitleRe.FindStringSubmatch(table)[1]
	typeName := spaceSepToCamel(tableTitle)

	tableRowRe := regexp.MustCompile(`(?s)<tr>\s*(<td.*?>.*?</td>\s*){3}\s*</tr>`)
	tableRows := tableRowRe.FindAllString(table, -1)

	var parsedRows []string
	for _, row := range tableRows {
		parsedRows = append(parsedRows, parseTableRow(row))
	}
	fields := strings.Join(parsedRows, "\n")

	typeStr := fmt.Sprintf("type api%s struct {\n%s\n}", typeName, fields)
	formattedTypeStr, _ := format.Source([]byte(typeStr))
	return string(formattedTypeStr)
}

func parseTableRow(row string) string {
	rowElementRe := regexp.MustCompile(`(?s)<td.*?>.*?</td>`)
	rowElements := rowElementRe.FindAllString(row, -1)

	elemContentsRe := regexp.MustCompile(`(?s)<td.*?>(.*?)</td>`)
	fieldNameRaw := elemContentsRe.FindStringSubmatch(rowElements[0])[1]
	fieldName := snakeToCamel(fieldNameRaw)

	fieldTypeRaw := elemContentsRe.FindStringSubmatch(rowElements[2])[1]
	fieldType := parseFieldType(fieldTypeRaw)

	parsed := fmt.Sprintf("%s %s `json:\"%s\"`", fieldName, fieldType, fieldNameRaw)

	return parsed
}

func parseFieldType(elem string) string {
	fieldType := ""
	if regexp.MustCompile(`object`).MatchString(elem) {
		fieldType = fmt.Sprintf("map[string]interface{}")
	} else if regexp.MustCompile(`APIReference`).MatchString(elem) {
		fieldType = fmt.Sprintf("APIReference")
	} else if regexp.MustCompile(`Choice`).MatchString(elem) {
		fieldType = fmt.Sprintf("Choice")
	} else {
		scalar := regexp.MustCompile(`\S+$`).FindString(elem)
		fieldType = fmt.Sprintf("%s", apiScalarToGoScalar[scalar])
	}

	if fieldType == "" && regexp.MustCompile(`(?s).*string.+`).MatchString(elem) {
		fieldType = fmt.Sprintf("URLRefString")
	}

	if regexp.MustCompile(`list`).MatchString(elem) {
		fieldType = fmt.Sprintf("[]%s", fieldType)
	}

	return fieldType
}
